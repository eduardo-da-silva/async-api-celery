{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Informa\u00e7\u00f5es iniciais","text":"<p>Essas s\u00e3o notas de aula para o curso de API REST ass\u00edncrona usando Celery, dos professores Eduardo da Silva e Marco Andr\u00e9 Lopes Mendes.</p> <p>Esse material \u00e9 melhor absorvido durante as atividades realizadas durante o Curso.</p> <p>Bons estudos!</p>"},{"location":"async-comm/","title":"Por que comunica\u00e7\u00e3o ass\u00edncrona","text":"<p>Na forma de tradicional de comunica\u00e7\u00e3o s\u00edncrona, o cliente faz uma requisi\u00e7\u00e3o ao servidor e espera a resposta. Durante esse tempo, o cliente fica bloqueado, ou seja, n\u00e3o pode fazer mais nada at\u00e9 que a resposta seja recebida. Isso pode ser um problema em aplica\u00e7\u00f5es web, onde o tempo de resposta do servidor pode ser alto, e o usu\u00e1rio pode ficar frustrado esperando.</p> <p>Na comunica\u00e7\u00e3o ass\u00edncrona, o cliente faz uma requisi\u00e7\u00e3o ao servidor e n\u00e3o espera pela resposta imediatamente. Em vez disso, o cliente pode continuar a executar outras tarefas enquanto aguarda a resposta do servidor. Isso melhora a experi\u00eancia do usu\u00e1rio, pois a interface do aplicativo pode permanecer responsiva, mesmo que o servidor esteja demorando para responder.</p> <p>Alguns cen\u00e1rios onde a comunica\u00e7\u00e3o ass\u00edncrona \u00e9 ben\u00e9fica incluem:</p> <ul> <li>Processamento de tarefas demoradas: em aplica\u00e7\u00f5es web, algumas tarefas podem levar muito tempo para serem conclu\u00eddas, como o processamento de imagens ou a gera\u00e7\u00e3o de relat\u00f3rios. Nesses casos, a comunica\u00e7\u00e3o ass\u00edncrona permite que o usu\u00e1rio continue a usar a aplica\u00e7\u00e3o enquanto a tarefa est\u00e1 sendo processada em segundo plano.</li> <li>Notifica\u00e7\u00f5es em tempo real: em aplica\u00e7\u00f5es que exigem atualiza\u00e7\u00f5es em tempo real, como chats ou sistemas de monitoramento, a comunica\u00e7\u00e3o ass\u00edncrona permite que o servidor envie notifica\u00e7\u00f5es para o cliente assim que novos dados estiverem dispon\u00edveis, sem que o cliente precise fazer requisi\u00e7\u00f5es constantes ao servidor.</li> <li>Integra\u00e7\u00e3o com servi\u00e7os externos: em aplica\u00e7\u00f5es que dependem de servi\u00e7os externos, como APIs de terceiros, a comunica\u00e7\u00e3o ass\u00edncrona permite que o cliente fa\u00e7a requisi\u00e7\u00f5es a esses servi\u00e7os sem bloquear a interface do usu\u00e1rio, melhorando a experi\u00eancia do usu\u00e1rio.</li> <li>Envio de e-mails: em aplica\u00e7\u00f5es que enviam e-mails, a comunica\u00e7\u00e3o ass\u00edncrona permite que o envio de e-mails seja feito em segundo plano, sem bloquear a interface do usu\u00e1rio.</li> <li>Upload e convers\u00e3o de arquivos: em aplica\u00e7\u00f5es que permitem o upload e convers\u00e3o de arquivos, a comunica\u00e7\u00e3o ass\u00edncrona permite que o usu\u00e1rio continue a usar a aplica\u00e7\u00e3o enquanto o arquivo est\u00e1 sendo processado em segundo plano.</li> <li>Processamento de relat\u00f3rios: em aplica\u00e7\u00f5es que geram relat\u00f3rios, a comunica\u00e7\u00e3o ass\u00edncrona permite que o usu\u00e1rio continue a usar a aplica\u00e7\u00e3o enquanto o relat\u00f3rio est\u00e1 sendo gerado em segundo plano.</li> </ul>"},{"location":"async-comm/#exemplo-de-comunicacao-sincrona-bloqueada","title":"Exemplo de comunica\u00e7\u00e3o s\u00edncrona bloqueada","text":"<p>Faremos um exemplo simples, usando um servidor FastAPI para ilustrar a comunica\u00e7\u00e3o s\u00edncrona bloqueada. Inicialmente, vamos criar um diret\u00f3rio para o projeto, e abrir no VSCode. Dentro do diret\u00f3rio do projeto, criaremos um ambiente virtual e instalaremos o FastAPI e o Uvicorn:</p> LinuxWindows <pre><code>python -m venv venv\nsource venv/bin/activate\npip install fastapi uvicorn\n</code></pre> <pre><code>python -m venv venv\n.\\venv\\Scripts\\activate\npip install fastapi uvicorn\n</code></pre> <p>Crie uma pasta chamada <code>src</code> e adicione um arquivo <code>main.py</code>, com o seguinte conte\u00fado.:</p> ./src/main.py<pre><code>from fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/sync-process/\")\ndef sync_process():\n    import time\n\n    time.sleep(10)\n    return {\"message\": \"Processamento longo conclu\u00eddo\"}\n</code></pre> <p>Em seguinte, iniciamos o servidor com o comando:</p> <pre><code>uvicorn src.main:app --reload\n</code></pre> <p>Para testar, acesse a documenta\u00e7\u00e3o Swagger UI em <code>http://localhost:8000/docs</code>. Clique no endpoint <code>/sync-process/</code> e depois em \"Try it out\" e \"Execute\". Voc\u00ea ver\u00e1 que a requisi\u00e7\u00e3o demora 10 segundos para ser conclu\u00edda, e durante esse tempo, o navegador fica bloqueado, ou seja, voc\u00ea n\u00e3o pode fazer mais nada at\u00e9 que a resposta seja recebida.</p> <p>Caso voc\u00ea tivesse feito um cliente API REST, por exemplo em um framework JavaScript como Vue.js ou React, a interface do usu\u00e1rio ficaria bloqueada durante esse tempo, o que n\u00e3o \u00e9 uma boa experi\u00eancia para o usu\u00e1rio.</p>"},{"location":"basic-sample/","title":"Exemplo b\u00e1sico usando Celery com FastAPI e Redis","text":"<p>Neste exemplo, criaremos um novo endpoint na aplica\u00e7\u00e3o FastAPI que usar\u00e1 o Celery para processar uma tarefa em segundo plano. A tarefa ser\u00e1 simular um processamento longo, como no exemplo anterior, mas agora sem bloquear o servidor.</p>"},{"location":"basic-sample/#instalacao-das-dependencias","title":"Instala\u00e7\u00e3o das depend\u00eancias","text":"<p>Primeiro, precisamos instalar as depend\u00eancias necess\u00e1rias. J\u00e1 vamos instalar tudo de uma vez. No ambiente virtual do projeto, instale o Celery:</p> <pre><code>pip install celery redis python-dotenv flower\n</code></pre> Depend\u00eancias instaladas <p>As depend\u00eancias instaladas s\u00e3o:</p> <ul> <li><code>celery</code>: A biblioteca principal para comunica\u00e7\u00e3o ass\u00edncrona.</li> <li><code>redis</code>: O broker de mensagens que usaremos para gerenciar as filas de tarefas.</li> <li><code>python-dotenv</code>: Para carregar vari\u00e1veis de ambiente a partir de um arquivo <code>.env</code>.</li> <li><code>flower</code>: Uma ferramenta para monitorar e gerenciar tarefas do Celery.</li> </ul>"},{"location":"basic-sample/#configuracao-do-celery","title":"Configura\u00e7\u00e3o do Celery","text":"<p>Vamos seguir os passos para configurar o Celery na aplica\u00e7\u00e3o.</p>"},{"location":"basic-sample/#configuracao-do-ambiente","title":"Configura\u00e7\u00e3o do ambiente","text":"<p>Inicialmente, vamos criar um arquivo <code>.env</code> na raiz do projeto, para armazenar as vari\u00e1veis de ambiente necess\u00e1rias para a configura\u00e7\u00e3o do Celery. O conte\u00fado do arquivo <code>.env</code> ser\u00e1 o seguinte:</p> .env<pre><code>REDIS_URL=redis://:myStrongPassword@localhost:6379/0\n</code></pre> <p>Estamos definindo a vari\u00e1vel <code>REDIS_URL</code>, que cont\u00e9m a URL de conex\u00e3o com o Redis, incluindo a senha que definimos anteriormente.</p>"},{"location":"basic-sample/#definindo-as-variaveis-de-configuracao-e-o-celery","title":"Definindo as vari\u00e1veis de configura\u00e7\u00e3o e o Celery","text":"<p>Agora, criaremos um arquivo <code>config.py</code> dentro da pasta <code>src</code>, que conter\u00e1 a configura\u00e7\u00e3o do Celery. O conte\u00fado do arquivo <code>config.py</code> ser\u00e1 o seguinte:</p> ./src/config.py<pre><code>import os\nfrom dotenv import load_dotenv\nfrom celery import Celery\n\nload_dotenv()\n\nREDIS_URL = os.getenv(\"REDIS_URL\", \"redis://localhost:6379/0\")\n\ncelery_app = Celery(\"tasks\", broker=REDIS_URL, backend=REDIS_URL)\n</code></pre> <p>Esse arquivo carrega as vari\u00e1veis de ambiente do arquivo <code>.env</code> e define a vari\u00e1vel <code>REDIS_URL</code>, que ser\u00e1 usada para configurar o Celery. Caso a vari\u00e1vel de ambiente n\u00e3o esteja definida, ele usar\u00e1 um valor padr\u00e3o.</p>"},{"location":"basic-sample/#definindo-o-worker-do-celery","title":"Definindo o worker do Celery","text":"<p>Agora, criaremos um arquivo <code>worker.py</code> dentro da pasta <code>src</code>, que conter\u00e1 a defini\u00e7\u00e3o do worker do Celery. O conte\u00fado do arquivo <code>worker.py</code> ser\u00e1 o seguinte:</p> ./src/worker.py<pre><code>from app.config import celery_app\n</code></pre> <p>Nesse caso n\u00e3o precisamos adicionar mais nada, pois o worker do Celery j\u00e1 est\u00e1 configurado no arquivo <code>config.py</code>. Embora esse arquivo possa parecer redundante, ele \u00e9 \u00fatil para iniciar o worker do Celery a partir da linha de comando.</p>"},{"location":"basic-sample/#criando-a-tarefa-assincrona","title":"Criando a tarefa ass\u00edncrona","text":"<p>Agora, criaremos um arquivo <code>tasks.py</code> dentro da pasta <code>src</code>, que conter\u00e1 a defini\u00e7\u00e3o da tarefa ass\u00edncrona que ser\u00e1 executada pelo Celery. O conte\u00fado do arquivo <code>tasks.py</code> ser\u00e1 o seguinte:</p> ./src/tasks.py<pre><code>from app.config import celery_app\n\n@celery_app.task\ndef long_task():\n    import time\n    time.sleep(10)\n    return \"Tarefa conclu\u00edda\"\n</code></pre> <p>Essa tarefa simula um processamento longo, dormindo por 10 segundos antes de retornar uma mensagem indicando que a tarefa foi conclu\u00edda. Note que essa mensagem de retorno n\u00e3o ser\u00e1 diretamente vis\u00edvel para o cliente que fez a requisi\u00e7\u00e3o, mas pode ser consultada posteriormente. Ela \u00e9 enviada e armazenada no backend de resultados do Celery, que neste caso \u00e9 o Redis.</p>"},{"location":"basic-sample/#atualizando-o-servidor-fastapi","title":"Atualizando o servidor FastAPI","text":"<p>Agora, vamos atualizar o arquivo <code>main.py</code> dentro da pasta <code>src</code>, para adicionar um novo endpoint que usar\u00e1 o Celery para processar a tarefa em segundo plano. O conte\u00fado atualizado do arquivo <code>main.py</code> ser\u00e1 o seguinte:</p> ./src/main.py<pre><code>@app.get(\"/async-process/\")\ndef async_process():\n    from app.tasks import long_task\n    task = long_task.delay()\n    return {\"task_id\": task.id, \"status\": \"Tarefa iniciada\"}\n</code></pre> <p>Esse novo endpoint <code>/async-process/</code> chama a tarefa <code>long_task</code> de forma ass\u00edncrona, usando o m\u00e9todo <code>delay()</code>, que enfileira a tarefa para ser executada pelo Celery. O endpoint retorna imediatamente um JSON contendo o ID da tarefa e uma mensagem indicando que a tarefa foi iniciada.</p> C\u00f3digo completo do main.py ./src/main.py<pre><code>from fastapi import FastAPI\n\nfrom app.tasks import long_task\n\napp = FastAPI()\n\n@app.get(\"/sync-process/\")\ndef sync_process():\n    import time\n\n    time.sleep(10)\n    return {\"message\": \"Processamento longo conclu\u00eddo\"}\n\n@app.get(\"/async-process/\")\ndef async_process():\n    task = long_task.delay()\n    return {\"task_id\": task.id, \"status\": \"Tarefa iniciada\"}\n</code></pre> <p>Note que o endpoint <code>/sync-process/</code> permanece inalterado, para que possamos comparar o comportamento dos dois endpoints. Ainda, no novo endpoint, importamos a tarefa <code>long_task</code> diretamente no escopo da fun\u00e7\u00e3o no exemplo, mas a importa\u00e7\u00e3o poderia ser feita no in\u00edcio do arquivo, como no exemplo comentado.</p> Importa\u00e7\u00e3o dentro da fun\u00e7\u00e3o <p>Embora seja comum fazer a importa\u00e7\u00e3o no in\u00edcio do arquivo, como no exemplo comentado, pode ser interessante fazer a importa\u00e7\u00e3o dentro da fun\u00e7\u00e3o, para evitar problemas de importa\u00e7\u00e3o circular em projetos maiores, quando o arquivo <code>tasks.py</code> pode acabar importando algo do <code>main.py</code>.</p>"},{"location":"basic-sample/#executando-o-exemplo","title":"Executando o exemplo","text":"<p>Agora, vamos executar o exemplo completo. Precisamos iniciar o servidor FastAPI, o worker do Celery e o Flower para monitorar as tarefas.</p> <pre><code>uvicorn src.main:app --reload\ncelery -A src.worker worker --loglevel=info\ncelery -A src.worker flower\n</code></pre> <p>Vamos explicar os comandos:</p> <ul> <li><code>uvicorn src.main:app --reload</code>: Inicia o servidor FastAPI, com recarregamento autom\u00e1tico. A aplica\u00e7\u00e3o estar\u00e1 dispon\u00edvel em <code>http://localhost:8000</code>. E a documenta\u00e7\u00e3o Swagger UI em <code>http://localhost:8000/docs</code>.</li> <li><code>celery -A src.worker worker --loglevel=info</code>: Inicia o worker do Celery, que ficar\u00e1 escutando as tarefas enfileiradas.</li> <li><code>celery -A src.worker flower</code>: Inicia o Flower, que \u00e9 uma interface web para monitorar as tarefas do Celery. Acesse em <code>http://localhost:5555</code>.</li> </ul> <p>Vamos agora testar o novo endpoint <code>/async-process/</code>. Acesse a documenta\u00e7\u00e3o Swagger UI em <code>http://localhost:8000/docs</code>, clique no endpoint <code>/async-process/</code>, depois em \"Try it out\" e \"Execute\". Voc\u00ea ver\u00e1 que a requisi\u00e7\u00e3o retorna imediatamente, com o ID da tarefa e a mensagem indicando que a tarefa foi iniciada.</p> <p>Caso voc\u00ea acesse a visualiza\u00e7\u00e3o do Flower em <code>http://localhost:5555</code>, ver\u00e1 a tarefa sendo processada pelo worker do Celery. Ap\u00f3s 10 segundos, a tarefa ser\u00e1 conclu\u00edda, e voc\u00ea poder\u00e1 ver o status da tarefa atualizado na interface do Flower.</p>"},{"location":"fundamentals/","title":"Fundamentos da comunica\u00e7\u00e3o ass\u00edncrona","text":"<p>Vamos agora entender alguns fundamentos b\u00e1sicos sobre comunica\u00e7\u00e3o ass\u00edncrona, e os principais elementos envolvidos nesse tipo de comunica\u00e7\u00e3o.</p> <p>Na comunica\u00e7\u00e3o ass\u00edncrona, os principais elementos envolvidos s\u00e3o:</p> <ul> <li>Broker de mensagens: \u00e9 um componente que gerencia a fila de mensagens, com a fun\u00e7\u00e3o de armazenar mensagens ou tarefas na fila. O broker de mensagens pode ser um sistema de mensagens como RabbitMQ, Redis, ou outro sistema de mensagens que suporte filas.</li> <li>Worker: \u00e9 um componente que consome as mensagens da fila de mensagens, e processa as tarefas solicitadas pelo cliente. O worker pode ser executado em um processo separado, ou em um servidor dedicado, e pode ser escalado horizontalmente para lidar com um grande volume de requisi\u00e7\u00f5es. Entre os principais exemplos para Python est\u00e3o Celery, RQ (Redis Queue), Dramatiq, entre outros.</li> <li>Backend de resultados: \u00e9 um componente que armazena os resultados das tarefas processadas pelos workers. O backend de resultados pode ser um banco de dados, um sistema de cache, ou outro tipo de armazenamento persistente. Um exemplo comum \u00e9 o Redis, mas pode ser usado tamb\u00e9m bancos relacionais como PostgreSQL, MySQL, SQLite, entre outros.</li> </ul> <p>Podemos fazer uma analogia com um sistema de troca de correspond\u00eancias via correios tradicional. Nesse caso:</p> <ul> <li>Broker de mensagens: seria a caixa de correio do remetente, onde as cartas s\u00e3o depositadas para serem enviadas</li> <li>Worker: seriam os carteiros, que pegam as cartas das filas e as entregam</li> <li>Backend de resultados: seria um sistema de rastreamento de correspond\u00eancias, onde o remetente pode verificar se a carta foi entregue e quando.</li> </ul>"},{"location":"fundamentals/#celery-o-orquestrador-de-tarefas-assincronas","title":"Celery - O orquestrador de tarefas ass\u00edncronas","text":"<p>O Celery \u00e9 uma biblioteca Python que facilita a implementa\u00e7\u00e3o de comunica\u00e7\u00e3o ass\u00edncrona em aplica\u00e7\u00f5es. Ele \u00e9 um orquestrador de tarefas ass\u00edncronas, que permite que voc\u00ea defina tarefas que podem ser executadas em segundo plano, sem bloquear a execu\u00e7\u00e3o do c\u00f3digo principal da aplica\u00e7\u00e3o.</p> <p>O Celery \u00e9 altamente escal\u00e1vel, e pode ser usado em aplica\u00e7\u00f5es de pequeno a grande porte. Ele suporta m\u00faltiplos brokers de mensagens, incluindo RabbitMQ, Redis, Amazon SQS, entre outros. Al\u00e9m disso, o Celery suporta m\u00faltiplos backends de resultados, incluindo Redis, bancos relacionais como PostgreSQL, MySQL, SQLite, entre outros.</p> <p>O Celery \u00e9 f\u00e1cil de usar, e possui uma API simples e intuitiva. Ele permite que voc\u00ea defina tarefas como fun\u00e7\u00f5es Python normais, e fornece mecanismos para agendar a execu\u00e7\u00e3o dessas tarefas em segundo plano. O Celery tamb\u00e9m suporta a execu\u00e7\u00e3o de tarefas peri\u00f3dicas, o que \u00e9 \u00fatil para tarefas que precisam ser executadas em intervalos regulares.</p> <p>O BackgroundTasks do FastAPI</p> <p>No caso do uso do FastAPI, poder\u00edamos fazer uso da fun\u00e7\u00e3o <code>BackgroundTasks</code>, que permite a execu\u00e7\u00e3o de tarefas em segundo plano, mas essa abordagem \u00e9 limitada, pois as tarefas s\u00e3o executadas no mesmo processo do servidor web, o que pode levar a problemas de desempenho e escalabilidade. Al\u00e9m disso, o <code>BackgroundTasks</code> n\u00e3o oferece suporte a filas de mensagens, o que limita a capacidade de lidar com um grande volume de requisi\u00e7\u00f5es.</p>"},{"location":"fundamentals/#redis-o-corretor-de-mensagens","title":"Redis - O corretor de mensagens","text":"<p>O Redis \u00e9 um sistema de armazenamento de dados em mem\u00f3ria, que pode ser usado como um broker de mensagens para comunica\u00e7\u00e3o ass\u00edncrona. Ele \u00e9 altamente escal\u00e1vel, e pode lidar com um grande volume de requisi\u00e7\u00f5es. O Redis \u00e9 f\u00e1cil de usar, e possui uma API simples e intuitiva. Ele suporta m\u00faltiplos tipos de dados, incluindo strings, listas, conjuntos, hashes, entre outros.</p> <p>O Redis \u00e9 uma escolha popular como broker de mensagens para comunica\u00e7\u00e3o ass\u00edncrona, devido \u00e0 sua alta performance e escalabilidade. Ele \u00e9 capaz de lidar com um grande volume de mensagens, e pode ser usado em aplica\u00e7\u00f5es de pequeno a grande porte.</p> <p>RabbitMQ - Outra op\u00e7\u00e3o de broker de mensagens</p> <p>Uma alternativa ao Redis como broker de mensagens \u00e9 o RabbitMQ, que \u00e9 um sistema altamente escal\u00e1vel, e pode lidar com um grande volume de requisi\u00e7\u00f5es. Ele suporta m\u00faltiplos protocolos de mensagens, incluindo AMQP, MQTT, entre outros. O RabbitMQ \u00e9 uma escolha popular para aplica\u00e7\u00f5es que exigem alta confiabilidade e durabilidade das mensagens.</p>"},{"location":"fundamentals/#usando-um-docker-compose-para-subir-o-redis","title":"Usando um docker compose para subir o Redis","text":"<p>Para facilitar o uso do Redis como broker de mensagens, podemos usar um arquivo <code>docker-compose.yml</code> para subir uma inst\u00e2ncia do Redis em um cont\u00eainer Docker. O arquivo <code>docker-compose.yml</code> pode ser o seguinte:</p> docker-compose.yml<pre><code>services:\n  redis:\n    image: redis:8\n    container_name: redis\n    command: redis-server --requirepass myStrongPassword\n    ports:\n      - '6379:6379'\n    volumes:\n      - redis_data:/data\n</code></pre> <p>Para subir o Redis, basta executar o comando:</p> <pre><code>docker-compose up\n</code></pre> <p>Agora, quando formos configurar o Celery, podemos usar o endere\u00e7o <code>redis://:myStrongPassword@localhost:6379/0</code> para conectar ao Redis, onde <code>myStrongPassword</code> \u00e9 a senha definida no comando de inicializa\u00e7\u00e3o do Redis. Este \u00e9 uma forma simples, apenas para testes locais. Em um ambiente de produ\u00e7\u00e3o, \u00e9 importante configurar o Redis com mais seguran\u00e7a, incluindo o uso de senhas fortes, configura\u00e7\u00e3o de firewalls, entre outras medidas de seguran\u00e7a.</p>"},{"location":"sending-email/","title":"Envio de emails em segundo plano","text":"<p>Em aplica\u00e7\u00f5es web, o envio de emails \u00e9 uma tarefa comum, mas que pode ser demorada, dependendo do provedor de email e da quantidade de emails a serem enviados. Se o envio de emails for feito de forma s\u00edncrona, ou seja, bloqueando a requisi\u00e7\u00e3o do usu\u00e1rio at\u00e9 que o email seja enviado, isso pode levar a uma m\u00e1 experi\u00eancia do usu\u00e1rio, que pode ficar esperando por um longo tempo.</p> <p>Para resolver esse problema, podemos usar comunica\u00e7\u00e3o ass\u00edncrona para enviar emails em segundo plano, sem bloquear a requisi\u00e7\u00e3o do usu\u00e1rio. Dessa forma, o usu\u00e1rio pode continuar a usar a aplica\u00e7\u00e3o enquanto o email est\u00e1 sendo enviado em segundo plano. Isso melhora a experi\u00eancia do usu\u00e1rio, e tamb\u00e9m permite que a aplica\u00e7\u00e3o lide com um maior volume de requisi\u00e7\u00f5es, j\u00e1 que o envio de emails n\u00e3o bloqueia o processamento das requisi\u00e7\u00f5es.</p> <p>Nos nossos exemplo, usaremos a ferramenta Mailtrap, que \u00e9 um servi\u00e7o de email para desenvolvimento e teste. O Mailtrap permite que voc\u00ea envie emails para uma caixa de entrada virtual, onde voc\u00ea pode visualizar os emails enviados, sem que eles sejam realmente entregues aos destinat\u00e1rios. Isso \u00e9 \u00fatil para testar o envio de emails em aplica\u00e7\u00f5es web, sem correr o risco de enviar emails reais para usu\u00e1rios.</p>"},{"location":"sending-email/#criando-uma-conta-no-mailtrap","title":"Criando uma conta no Mailtrap","text":"<p>Para criar uma conta no Mailtrap, acesse o site https://mailtrap.io/ e clique em \"Sign Up\". Preencha o formul\u00e1rio de cadastro com seu nome, email e senha, e clique em \"Create Account\". Voc\u00ea tamb\u00e9m pode se cadastrar usando sua conta do GitHub, Google ou LinkedIn. Ap\u00f3s criar a conta, voc\u00ea ser\u00e1 redirecionado para o painel do Mailtrap.</p> <p>Dentro da conta, voc\u00ea deve gerar um token de autentica\u00e7\u00e3o para usar na aplica\u00e7\u00e3o. Para isso, clique em \"Settings\" no menu lateral, e depois em \"API Tokens\". Em seguida, clique em \"Add Token\", e d\u00ea um nome para o token, como \"Celery Email\", e atribua a ele a permiss\u00e3o de Account Admin. Ent\u00e3o, copie o token gerado, pois voc\u00ea precisar\u00e1 dele para configurar o envio de emails na aplica\u00e7\u00e3o.</p>"},{"location":"sending-email/#configurando-o-mailtrap-na-aplicacao","title":"Configurando o mailtrap na aplica\u00e7\u00e3o","text":"<p>Inicialmente, vamos adicionar as vari\u00e1veis de ambiente necess\u00e1rias para configurar o Mailtrap. No arquivo <code>.env</code>, adicione as seguintes linhas:</p> .env<pre><code>REDIS_URL=redis://:myStrongPassword@localhost:6379/0\n\nMAILTRAP_TOKEN=MEU_TOKEN_GERADO_ANTERIORMENTE\nMAIL_FROM=no-reply@meucurso.ifc.dev\n</code></pre> <p>Substitua o valor de <code>MAILTRAP_TOKEN</code> pelo token gerado na sua conta do Mailtrap. A vari\u00e1vel <code>MAIL_FROM</code> define o endere\u00e7o de email que ser\u00e1 usado como remetente nos emails enviados pela aplica\u00e7\u00e3o.</p> <p>Em seguida, edite o arquivo <code>config.py</code> para adicionar as novas vari\u00e1veis de ambiente:</p> ./src/config.py<pre><code>MAILTRAP = {\n    \"token\": os.getenv(\"MAILTRAP_TOKEN\"),\n    \"from_email\": os.getenv(\"MAIL_FROM\"),\n}\n\nclient_mt = mt.MailtrapClient(token=MAILTRAP[\"token\"])\n...\n</code></pre> Vers\u00e3o completa do arquivo config.py <p>O arquivo <code>config.py</code> completo deve ficar assim:</p> ./src/config.py<pre><code>import os\nfrom dotenv import load_dotenv\nfrom celery import Celery\n\nload_dotenv()\n\nREDIS_URL = os.getenv(\"REDIS_URL\", \"redis://localhost:6379/0\")\n\nMAILTRAP = {\n    \"token\": os.getenv(\"MAILTRAP_TOKEN\"),\n    \"from_email\": os.getenv(\"MAIL_FROM\"),\n}\n\ncelery_app = Celery(\"tasks\", broker=REDIS_URL, backend=REDIS_URL)\n</code></pre>"},{"location":"sending-email/#definindo-a-tarefa-de-envio-de-email","title":"Definindo a tarefa de envio de email","text":"<p>Agora, criaremos uma nova tarefa no Celery para enviar emails usando o Mailtrap. No arquivo <code>tasks.py</code>, import as vari\u00e1veis necess\u00e1rias no in\u00edcio do arquivo e instancie o cliente mailtrap:</p> ./src/tasks.py<pre><code>import asyncio\nimport mailtrap as mt\n\nfrom app.config import MAILTRAP\n\nclient_mt = mt.MailtrapClient(token=MAILTRAP[\"token\"])\n</code></pre> <p>Em seguida, defina a tarefa <code>send_email</code> tamb\u00e9m dentro do arquivo <code>tasks.py</code>:</p> ./src/tasks.py<pre><code>@celery_app.task\ndef process_data_and_sending_email(data: str, to_email: str):\n    import time\n\n    time.sleep(10)\n\n    subject = \"Processamento conclu\u00eddo\"\n    body = f\"O processamento dos dados foi conclu\u00eddo com sucesso. Dados processados: {data}\"\n    asyncio.run(send_email(to_email, subject, body))\n\nasync def send_email(to_email: str, subject: str, body: str):\n    mail = mt.Mail(\n        sender=mt.Address(email=\"mailtrap@demomailtrap.co\", name=\"Mailtrap Test\"),\n        to=[mt.Address(email=to_email, name=\"User\")],\n        subject=subject,\n        text=body,\n    )\n    client_mt.send(mail)\n</code></pre> Vers\u00e3o completa do arquivo tasks.py ./src/tasks.py<pre><code>from app.config import celery_app, MAILTRAP\n\nclient_mt = mt.MailtrapClient(token=MAILTRAP[\"token\"])\n\n@celery_app.task\ndef long_task():\n    import time\n    time.sleep(10)\n    return \"Tarefa conclu\u00edda\"\n    celery_app = Celery(\n        \"tasks\",\n        broker=\"redis://localhost:6379/0\",\n        backend=\"redis://localhost:6379/0\"\n    )\n\n@celery_app.task\ndef process_data_and_sending_email(data: str, to_email: str):\n    import time\n\n    time.sleep(10)\n\n    subject = \"Processamento conclu\u00eddo\"\n    body = f\"O processamento dos dados foi conclu\u00eddo com sucesso. Dados processados: {data}\"\n    asyncio.run(send_email(to_email, subject, body))\n\nasync def send_email(to_email: str, subject: str, body: str):\n    mail = mt.Mail(\n        sender=mt.Address(email=\"mailtrap@demomailtrap.co\", name=\"Mailtrap Test\"),\n        to=[mt.Address(email=to_email, name=\"User\")],\n        subject=subject,\n        text=body,\n    )\n    client_mt.send(mail)\n</code></pre> <p>Note que a tarefa <code>process_data_and_sending_email</code> simula um processamento demorado, dormindo por 10 segundos, e depois chama a fun\u00e7\u00e3o <code>send_email</code> para enviar o email usando o Mailtrap. A fun\u00e7\u00e3o <code>send_email</code> cria um objeto <code>Mail</code> com os detalhes do email, e usa o cliente do Mailtrap para enviar o email. Note que a fun\u00e7\u00e3o <code>send_email</code> \u00e9 uma fun\u00e7\u00e3o ass\u00edncrona, e por isso usamos <code>asyncio.run</code> para execut\u00e1-la dentro da tarefa do Celery.</p> <p>Note tamb\u00e9m que usamos um endere\u00e7o de email fict\u00edcio como remetente (<code>mailtrap@demomailtrap.co</code>). Esse endere\u00e7o \u00e9 aceito pelo Mailtrap para testes, mas em uma aplica\u00e7\u00e3o real, voc\u00ea deve usar um endere\u00e7o de email v\u00e1lido e configurado corretamente. Contudo, \u00e9 necess\u00e1rio que o dom\u00ednio do email remetente seja v\u00e1lido, ou seja, que o dom\u00ednio possua registros DNS corretos para evitar que os emails sejam marcados como spam pelos provedores de email.</p>"},{"location":"sending-email/#atualizando-o-servidor-fastapi","title":"Atualizando o servidor FastAPI","text":"<p>Finalmente, vamos atualizar o servidor FastAPI para usar a nova tarefa de envio de email. No arquivo <code>main.py</code>, importe a nova tarefa no in\u00edcio do arquivo:</p> ./src/main.py<pre><code>@app.post(\"/process-and-email/\")\ndef process_email(email: str, data: dict):\n    task = process_data_and_sending_email.delay(data, email)\n    return {\"message\": \"Processamento iniciado\", \"task_id\": task.id}\n</code></pre> C\u00f3digo completo do main.py <p>O arquivo <code>main.py</code> completo deve ficar assim:</p> ./src/main.py<pre><code>from fastapi import FastAPI\n\nfrom app.tasks import long_task, process_data_and_sending_email\n\napp = FastAPI()\n\n@app.get(\"/sync-process/\")\ndef sync_process():\n    import time\n\n    time.sleep(10)\n    return {\"message\": \"Processamento longo conclu\u00eddo\"}\n\n@app.get(\"/async-process/\")\ndef async_process():\n    task = long_task.delay()\n    return {\"task_id\": task.id, \"status\": \"Tarefa iniciada\"}\n\n@app.post(\"/process-and-email/\")\ndef process_email(email: str, data: dict):\n    task = process_data_and_sending_email.delay(data, email)\n    return {\"message\": \"Processamento iniciado\", \"task_id\": task.id}\n</code></pre>"},{"location":"status-control/","title":"Controle de status das tarefas","text":"<p>Agora, vamos explorar como monitorar o status das tarefas ass\u00edncronas usando Celery. Isso \u00e9 crucial para entender o progresso das opera\u00e7\u00f5es em segundo plano e fornecer feedback aos usu\u00e1rios. Para isso, vamos simular uma atividade que leva algum tempo para ser conclu\u00edda, mas que pode ser controlada por meio de um status que informe o progresso.</p>"},{"location":"status-control/#criando-uma-tarefa-com-status","title":"Criando uma tarefa com status","text":"<p>Nesse caso, vamos criar uma tarefa que simula um processamento longo e que atualiza seu status periodicamente. Para isso, vamos usar o backend de resultados do Celery, que permite armazenar e consultar o estado das tarefas.</p> ./src/tasks.py<pre><code>@celery_app.task(bind=True)\ndef long_task_with_progress(self, total: int = 100):\n    import time\n    for i in range(total):\n        time.sleep(1)\n        self.update_state(state=\"PROGRESS\", meta={\"current\": i, \"total\": total})\n    return {\"status\": \"completed\"}\n</code></pre> Vers\u00e3o completa do arquivo tasks.py ./src/tasks.py<pre><code>from app.config import celery_app, MAILTRAP\n\nclient_mt = mt.MailtrapClient(token=MAILTRAP[\"token\"])\n\n@celery_app.task\ndef long_task():\n    import time\n    time.sleep(10)\n    return \"Tarefa conclu\u00edda\"\n    celery_app = Celery(\n        \"tasks\",\n        broker=\"redis://localhost:6379/0\",\n        backend=\"redis://localhost:6379/0\"\n    )\n\n@celery_app.task\ndef process_data_and_sending_email(data: str, to_email: str):\n    import time\n\n    time.sleep(10)\n\n    subject = \"Processamento conclu\u00eddo\"\n    body = f\"O processamento dos dados foi conclu\u00eddo com sucesso. Dados processados: {data}\"\n    asyncio.run(send_email(to_email, subject, body))\n\nasync def send_email(to_email: str, subject: str, body: str):\n    mail = mt.Mail(\n        sender=mt.Address(email=\"mailtrap@demomailtrap.co\", name=\"Mailtrap Test\"),\n        to=[mt.Address(email=to_email, name=\"User\")],\n        subject=subject,\n        text=body,\n    )\n    client_mt.send(mail)\n\n@celery_app.task(bind=True)\ndef long_task_with_progress(self, total: int = 100):\n    import time\n    for i in range(total):\n        time.sleep(1)\n        self.update_state(state=\"PROGRESS\", meta={\"current\": i, \"total\": total})\n    return {\"status\": \"completed\"}\n</code></pre> <p>Note que a tarefa <code>long_task_with_progress</code> est\u00e1 configurada com o par\u00e2metro <code>bind=True</code>, o que permite que a tarefa acesse seu pr\u00f3prio estado e atualize-o conforme necess\u00e1rio. A cada itera\u00e7\u00e3o do loop, a tarefa simula um atraso de 1 segundo e atualiza seu estado para \"PROGRESS\", incluindo informa\u00e7\u00f5es sobre o progresso atual.</p> <p>Essa informa\u00e7\u00e3o \u00e9 armazenada no backend de resultados do Celery, que pode ser consultado posteriormente para verificar o status da tarefa.</p>"},{"location":"status-control/#consumindo-a-terafa-e-verificando-o-status","title":"Consumindo a terafa e verificando o status","text":"<p>Para consumir essa tarefa e verificar seu status, voc\u00ea pode usar o seguinte c\u00f3digo:</p> ./src/main.py<pre><code>@app.post(\"/process-data-with-status/\")\ndef process_data_with_status(time: int = 100):\n    task = long_task_with_progress.delay(time)\n    return {\"message\": \"Processamento iniciado\", \"task_id\": task.id}\n\n\n@app.get(\"/task-status/{task_id}\")\ndef task_status(task_id: str):\n    result = AsyncResult(task_id, app=celery_app)\n    if result.state == \"PENDING\":\n        return {\"state\": result.state, \"progress\": 0}\n    if result.state == \"PROGRESS\":\n        return {\"state\": result.state, \"progress\": result.info.get(\"percent\", 0)}\n    if result.state == \"SUCCESS\":\n        return {\"state\": result.state, \"result\": result.result}\n    return {\"state\": result.state, \"info\": str(result.info)}\n</code></pre> Vers\u00e3o completa do arquivo main.py <p>O arquivo <code>main.py</code> completo deve ficar assim:</p> ./src/main.py<pre><code>from fastapi import FastAPI\nfrom celery.result import AsyncResult\n\nfrom app.tasks import long_task, process_data_and_sending_email, long_task_with_progress\n\napp = FastAPI()\n\n@app.get(\"/sync-process/\")\ndef sync_process():\n    import time\n\n    time.sleep(10)\n    return {\"message\": \"Processamento longo conclu\u00eddo\"}\n\n@app.get(\"/async-process/\")\ndef async_process():\n    task = long_task.delay()\n    return {\"task_id\": task.id, \"status\": \"Tarefa iniciada\"}\n\n@app.post(\"/process-and-email/\")\ndef process_email(email: str, data: dict):\n    task = process_data_and_sending_email.delay(data, email)\n    return {\"message\": \"Processamento iniciado\", \"task_id\": task.id}\n\n@app.post(\"/process-data-with-status/\")\ndef process_data_with_status(time: int = 100):\n    task = long_task_with_progress.delay(time)\n    return {\"message\": \"Processamento iniciado\", \"task_id\": task.id}\n\n@app.get(\"/task-status/{task_id}\")\ndef task_status(task_id: str):\n    result = AsyncResult(task_id, app=celery_app)\n    if result.state == \"PENDING\":\n        return {\"state\": result.state, \"progress\": 0}\n    if result.state == \"PROGRESS\":\n        return {\"state\": result.state, \"progress\": result.info.get(\"percent\", 0)}\n    if result.state == \"SUCCESS\":\n        return {\"state\": result.state, \"result\": result.result}\n    return {\"state\": result.state, \"info\": str(result.info)}\n</code></pre> <p>Note que a rota <code>/process-data-with-status/</code> inicia a tarefa <code>long_task_with_progress</code> e retorna o ID da tarefa. A rota <code>/task-status/{task_id}</code> permite consultar o status da tarefa usando seu ID. Dependendo do estado da tarefa, ela retorna informa\u00e7\u00f5es diferentes, como o progresso atual ou o resultado final. Fazemos uso da classe <code>AsyncResult</code> do Celery para consultar o estado da tarefa. Essa consulta \u00e9 feita ao backend de resultados configurado no Celery.</p> <p>Esse status tamb\u00e9m pode ser consultado diretamente no painel do Flower, que fornece uma interface web para monitorar as tarefas do Celery.</p>"}]}